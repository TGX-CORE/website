import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"Commands","description":"","frontmatter":{"outline":"deep","prev":false,"next":false},"headers":[],"relativePath":"guidebook/Commands/README.md","filePath":"guidebook/Commands/README.md"}');
const _sfc_main = { name: "guidebook/Commands/README.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="commands" tabindex="-1">Commands <a class="header-anchor" href="#commands" aria-label="Permalink to &quot;Commands&quot;">​</a></h1><p>Telegram allows a single message to contain multiple commands, <code>tgx-core</code> handles this by parsing the message and reading the entities the message contains.</p><p>Then the client emits every single commands the message contains, for instance a text message was sent <code>/command /hey /there</code>.</p><p>Here&#39;s how <code>tgx-core</code> handles this:</p><ul><li>Client will emit <code>message</code> <code>ClientEvent.Message</code></li><li>Client will emit <code>text</code> <code>ClientEvent.Text</code></li><li>Client will emit <code>command</code> <code>ClientEvent.Command</code></li><li>Client commands will emit <code>command</code></li><li>Client commands will emit <code>hey</code></li><li>Client commands will emit <code>there</code></li></ul><h2 id="listening-to-commands" tabindex="-1">Listening to Commands <a class="header-anchor" href="#listening-to-commands" aria-label="Permalink to &quot;Listening to Commands&quot;">​</a></h2><p><code>tgx-core</code> currently supports two methods on listening to commands.</p><h3 id="regsitries" tabindex="-1">Regsitries <a class="header-anchor" href="#regsitries" aria-label="Permalink to &quot;Regsitries&quot;">​</a></h3><p>Please refer to the <a href="./../Registries/Introduction.html"><code>Introduction</code></a> <a href="./../Registries/Commands.html"><code>Registries.Commands</code></a> on how to create command registries.</p><p>Once you have created a registry please refer to the <a href="./Registry Setup.html"><code>Registry Setup</code></a>.</p><h3 id="eventemitter" tabindex="-1">EventEmitter <a class="header-anchor" href="#eventemitter" aria-label="Permalink to &quot;EventEmitter&quot;">​</a></h3><p>The client has a manager called command which can be accessed via <code>Client.commands</code>. Whenever a command was received and parsed, you can listen to this manager.</p><div class="warning custom-block"><p class="custom-block-title">Registries</p><p>We recomment using the registries for at the moment since there are no other ways of updating the command.</p><p>But the usage of the event emitter is not limited, even if the command is not in the registry it is still emitted by the client for text message with command entities.</p></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">Client.commands.</span><span style="${ssrRenderStyle({ "--shiki-light": "#6F42C1", "--shiki-dark": "#B392F0" })}">on</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">(</span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">&#39;command&#39;</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">, (</span><span style="${ssrRenderStyle({ "--shiki-light": "#E36209", "--shiki-dark": "#FFAB70" })}">message</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">) </span><span style="${ssrRenderStyle({ "--shiki-light": "#D73A49", "--shiki-dark": "#F97583" })}">=&gt;</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}"> {</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    message.</span><span style="${ssrRenderStyle({ "--shiki-light": "#6F42C1", "--shiki-dark": "#B392F0" })}">replyText</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">(</span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">&#39;Command received!&#39;</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">})</span></span></code></pre></div></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("guidebook/Commands/README.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const README = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  README as default
};
